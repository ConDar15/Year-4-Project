\section{Conclusion}

In this document we set out to consider different methods of calculating common functions that one may find on a calculator, as such we succeeded and now have a deeper understanding of these functions. We have also gained an insight into how many calculators or computers may operate in calculating these functions.\\

In studying the root functions we have seen that while there are various methods available the most efficient method is the inverse newton square root method. This method converges quadratically to the required root and has a faster computation time than the standard Newton method, due to the lack of division operations. We saw that both of these methods outstripped the linear convergence of the bisection method, which while simple and efficient in the computational complexity sense, takes many more steps to achieve comparable accuracy and so is less efficient in computational time.\\

The digit by digit method of calculating square roots is interesting but ultimately of little practical value for modern computers due to its poor efficiency, though it has the interesting accuracy property of generating precisely one new digit each iteration. It's integer square root counterpart on the other hand is particularly interesting due to its \(\bigO(1)\) computational complexity and reliance on simple integer operations, and has possible practical applications if square roots are only needed to be accurate only to their integer part.\\

The root functions were successfully implemented in C, and when implemented with MPFR they were able to give answers accurate to arbitrary precision. In particular we were able to accurately compute \(\sqrt{2}\) accurate to 1000000 decimal places in a reasonably short span of time.\\

The trigonometric functions are an engaging topic to study and in doing so we found several very different methods for approximating their values. The geometric method studied is conceptually simple, but turned out to be complex to analyse, the end result giving a method that had a low computational complexity per iteration but required many iterations to achieve accuracy comparable to other methods.\\

The Taylor method for trigonometric functions was found to be the most efficient method, once the range of inputs was restricted. Further this method was easy to analyse the accuracy of due to the nature of the Taylor series, making it simple to guarantee a given degree of accuracy.\\

The CORDIC algorithm was the least efficient of the methods analysed, but as mentioned earlier, it still has its place. In particular CORDIC is still useful for simple systems that do not have the capability to handle floating point values, or for which the floating point operations take a long time to compute. Further the CORDIC algorithm has the capability to be directly implemented in hardware which would guarantee its use as being the most efficient method.\\

Finally, in the analysis of the Logarithmic and Exponential functions we saw more methods, ranging from the trivial and naive, to the detailed and reasoned. As expected the more considered methods that took advantage of aspects of the functions being approximated had better results than those that did not.\\

The Taylor methods for approximating both logarithms and exponentials were good starting points, as the methods were conceptually simple with low computational complexity for each iteration. Similar to what was witnessed in the analysis of the trigonometric functions, it was very simple to calculate the number of iterations required for a given accuracy, which is a desirable property to have.\\

Unlike the trigonometric section there was no one method that could be used to the efficiency of both the exponential function and the logarithm function. However, the two methods considered, both gave significant increases in efficiency over the Taylor method. The analysis of the two resulting methods showed that they both converged at a faster rate than the standard Taylor method, and neither of the methods was significantly more computationally complex at each iteration.\\

A final note is that while our analysis has shown when one algorithm is better than another, and even achieved good computational times, they still fall short of the built in versions from the standard C libraries. This is due to either the libraries using even methods other than those discussed here, the libraries utilising low level programming techniques to speed up computation, or a combination of the two.
